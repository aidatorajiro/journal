//! Main Program

pub mod constants;
pub mod typedef;
pub mod assets;
pub mod utils;
pub mod journalmanage;
pub mod ui;
pub mod tests;

use assets::loader::RawData;
use assets::loader::RawDataLoader;

use bevy::app::AppExit;
use bevy::reflect::{ReflectSerialize, ReflectDeserialize};
use bevy::render::Render;
use bevy::utils::HashSet;
use bevy::window::PresentMode;
use bevy::window::WindowClosed;
use bevy::winit::WinitSettings;
use bevy_mod_picking::DefaultPickingPlugins;
use journalmanage::systems::*;
use typedef::component::*;
use typedef::event::*;
use typedef::resource::*;

use bevy::{prelude::*, render::RenderApp};
use bevy_egui::EguiPlugin;
use bevy::render::{RenderSet};
use typedef::state::*;

/// Main function
pub fn run_the_journal() {
    let mut app = App::new();

    app
        .insert_resource(ClearColor(Color::rgb(37.0/256.0, 108.0/256.0, 122.0/256.0)))

        // Type registration for loading: also look at journalmanage.rs for type registration for saving
        .register_type::<Entity>()
        .register_type::<HashSet<Entity>>()
        .register_type_data::<HashSet<Entity>, ReflectSerialize>()
        .register_type_data::<HashSet<Entity>, ReflectDeserialize>()
        .register_type::<FragmentContents>()
        .register_type_data::<FragmentContents, ReflectSerialize>()
        .register_type_data::<FragmentContents, ReflectDeserialize>()
        .register_type::<String>()
        .register_type_data::<String, ReflectSerialize>()
        .register_type_data::<String, ReflectDeserialize>()
        .register_type::<Fragment>()
        .register_type::<EntityList>()
        .register_type::<Entry>()
        .register_type::<Tag>()
        .register_type::<TagEvent>()
        .register_type::<TagEventAction>()
        .register_type::<GameGraphDummy>()

        // plugins
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "! Bevy Journal ! (c) 2024 tora".to_string(),
                resolution: (800., 800.).into(),
                present_mode: PresentMode::AutoVsync,
                resizable: false,
                ..default()
            }),
            ..default()
        }))
        .add_plugins(EguiPlugin)
        .add_plugins(DefaultPickingPlugins)

        // app state
        .init_state::<AppState>()

        // designate itself as a desktop app
        .insert_resource(WinitSettings::desktop_app())

        // register events
        .add_event::<SyncFragments>()
        .add_event::<SyncFragmentsDone>()
        .add_event::<JumpToNewPage>()
        .add_event::<JumpToExplore>()
        .add_event::<JumpToLinear>()
        .add_event::<JumpToMigrate>()
        .add_event::<JumpToTop>()

        // register asset loaders
        .init_asset::<RawData>()
        .init_asset_loader::<RawDataLoader>()

        // initialize global game state/database 
        .init_resource::<StartupManagement>()
        .init_resource::<GameGraph>()

        // Root systems
        .add_systems(Startup, load_scene_system)
        .add_systems(Update, load_graph_system)
        .add_systems(Update, save_scene_system)
        .add_systems(Update, ui::router::event_listener)

        // journal manage
        .add_systems(Update, handle_sync_fragments)

        // TopPage System
        .add_systems(OnEnter(AppState::TopPage),
        (ui::inner::use_default_2d_camera, ui::top::top_enter))
        .add_systems(OnExit(AppState::TopPage),
        (ui::top::top_exit))
        .add_systems(Update,
            (ui::top::top_button_update_system))

        // Newpage system
        // After `handle_sync_fragments` finishes, Entity IDs generated by `handle_sync_fragments` are carried to `watch_sync_fragments_done`.
        // However, if `watch_sync_fragments_done` is called after `handle_sync_fragments` within the same frame, the query will be out of sync with the change `handle_sync_fragments` have made, leading to a crash.
        // Therefore, `watch_sync_fragments_done` must be run before `handle_sync_fragments`.
        // TODO: more sophisticated way of avoiding crash.
        .add_systems(OnEnter(AppState::NewPage),
        (ui::inner::use_default_2d_camera, ui::newpage::newpage_enter))
        .add_systems(OnExit(AppState::NewPage),
        ui::newpage::newpage_exit)
        .add_systems(Update,
            (ui::newpage::newpage_update,
                ui::newpage::watch_sync_fragments_done.before(handle_sync_fragments))
            .run_if(in_state(AppState::NewPage)))

        // Migrate system
        .add_systems(OnEnter(AppState::Migrate), 
        (ui::inner::use_default_2d_camera, ui::migrate::migrate_enter))
        .add_systems(OnExit(AppState::Migrate), 
        ui::migrate::migrate_exit)
        .add_systems(Update, 
            (ui::migrate::migrate_update, ui::migrate::system_drag_and_drop)
            .run_if(in_state(AppState::Explore)))

        // Explore system
        .add_systems(OnEnter(AppState::Explore),
            (ui::inner::delete_all_camera,
                     ui::explore::explore_enter))
        .add_systems(OnExit(AppState::Explore),
            ui::explore::explore_exit)
        .add_systems(Update,
            (
                ui::explore::explore_update_graph,
                ui::explore::explore_update_interaction,
                ui::explore::explore_update_buttons,
                ui::explore::keyboard_input)
                .run_if(in_state(AppState::Explore)));

    app.run();
}

/// When the main window is closed, quit the application
fn window_closed_handler(mut ev: EventReader<WindowClosed>, mut quit: EventWriter<AppExit>) {
    for e in ev.read() {
/*         if e.window.is_primary() {
            quit.send(AppExit::Success);
        } MIGRATION_TODO */
    }
}
