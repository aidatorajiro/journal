Journal History

[TODO]
ğŸ”ºä¸€æ—¦è«¦ã‚ TODO: Looking for typesetting and hopefully COLR support...
    oh! that looks nice!  https://github.com/dfrg/swash
âŒ TODO: åˆ†è§£ã‚„ã‚¿ã‚°ä»˜ã‘ãªã©ã®ã€ãƒ‡ãƒ¼ã‚¿ã‚’æ•´ãˆã‚‹ä½œæ¥­ã‚’ä¸€ç¨®ã®ã‚²ãƒ¼ãƒ ã¨ã—ã¦æ¥½ã—ã‚€ã€ã¿ãŸã„ãª...
âŒ TODO: Making 3D atmosphere?
âŒ TODO: id ä»˜ç•ª or è¡¨ç¤º => mozc dict ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
    ç„¡æ©Ÿçš„ãªIDã§ã¯ãªãã€ã•ã¾ã–ã¾ãªæ–‡è„ˆã¨ç¹‹ãŒã‚‹ã“ã¨ã®ã§ãã‚‹IDã€‚ä¸€æ–¹ã§uniquenessãªã©ã®ç”¨ä»¶ã‚‚æºãˆã¦ã„ã‚‹
âŒ TODO: ã‚¿ã‚°ã¥ã‘ã‚²ãƒ¼ãƒ 
âŒ TODO: åˆ†å²ã‚’ä½œã‚‹ã‚²ãƒ¼ãƒ ã€€ç•°ãªã‚‹journalã®fragmentåŒå£«ã‚’ãã£ã¤ã‘ã‚‹pathã‚’ä½œã‚‹ã€‚ãã†ã—ã¦æ–°ãŸãªjournalãŒèª•ç”Ÿã™ã‚‹ã€‚
    [ãã†ã„ãˆã°ã€fragmentè‡ªä½“ã«IDã‚’ã¤ã‘ãªãã‚ƒã­... fragmentè‡ªä½“ã®åˆ†å²ãƒ»åˆæµãƒ»ä»–ã®fragmentã¨ã®çµåˆã«ã‚ˆã£ã¦ç„¡æ•°ã®pathãŒã§ãã‚‹ä»•çµ„ã¿ã‚’ä½œã‚ŠãŸã„]
âŒ TODO: ãƒ‡ãƒ¼ã‚¿serialize & deserializeä¿å­˜ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ï¼ã“ã‚ŒãŒãªã„ã¨å§‹ã¾ã‚‰ãªã„ã‚ˆã­...
âŒ TODO: addãƒ¡ãƒ¢ äººåŠ›ã§ãƒ¡ãƒ¢ã‚’è¿½åŠ ã™ã‚‹
âŒ TODO: migrate facebookã‚„icloudãªã©ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ã£å¼µã£ã¦ãã‚‹

[2022-09-22]
when i open VSCode i couldnt use extension...
git init
gibo dump macos rust >> .gitignore

Read https://bevy-cheatbook.github.io/input/dnd.html

[2022-09-23]
Figuring out what can be used in the framework
Playing https://ramirezmike2.itch.io/usa-football-league-scouting-combine-xlv (winner of Bevy Jam #2 : https://itch.io/jam/bevy-jam-2/results)
    finding out it's quite slow...
    returning to old days of internet?
Search documentation - https://docs.rs/bevy/latest/bevy/?search=bundle
    Looking for "bundle" to see what can be used (such as texts, buttons, etc.)
seems like Bevy doesn't have text input...
    But looking MIDI section on the unofficial cookbook, maybe there's a possibility of 3rd-party extension library? â†’ found bevy_egui! https://github.com/mvlabat/bevy_egui
Bevy's "data-driven" way is similar to Modding! (especially that of X series, or maybe civilization or stellaris?)

[2022-09-27]
https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs
    Stage ã«ã¤ã„ã¦ã¹ã‚“ãã‚‡ã†ã—ãŸã‚ˆ
Sub-apps and multiple window
    ã‚‚ã¯ã‚„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã™ã‚‰æ›¸ã‹ã‚Œã¦ã„ãªã„é ˜åŸŸã«çªå…¥ã—ãŸã‹...
Meaning of Equal and Labels (like x, y, z) classifies language
    haskell - definition â†’ Free to split (pattern-match), fuse numbers and apply functions to labels (it is functional language, so "labels" aren't "variables"), like "x = (y, z)" or "(a, b) = c" or "y = f(x)". The notation "x =" is just the same as replacement of a code thereafter and even itself. Therefore, one may be able to fuse the whole program into one function without using any labels other than "main = ...".
    python - normal? language â†’ You can freely apply functions, split or merge variables.  The notation "x =" is NOT the same as replacement of code thereafter. For example, x = [1, 2, 3]; y = func(x); z = x + [4, 5] may not result in z = [1, 2, 3, 4, 5]. The first line does not promise that you can replace "x" with "[1, 2, 3]" in the last line ("z = x + [4, 5]"). In a simpler case, "x = x + 1" just means "add 1 to x" in Python, while in Haskell, it guarantees that you can replace "x" with "x + 1" in the very sentence "x = x + 1", therefore same as "x = (...(... + 1) + 1) + 1) + 1) + 1" (fixpoint operation).
    rust - borrowing â†’ The notation "x =" is NOT the same as replacement of code thereafter. In addition to the discussion on Python above, "=" also determines which variable is "borrow" and which variable is "move", deciding the timing these variables are freed. Therefore, you cannot freely merge or split variables through pattern-match or even applying function. Every time you apply function or pattern-match variables, you have to follow borrowing rules...

    ã“ã®ã‚ˆã†ãªã€€è¨€èªã”ã¨ã®ç¸›ã‚Šã®é•ã„ã‚‚Architectureã®ä¸€ã¤ã‹ã‚‚ï¼Ÿ
Quite useful page! https://bevy-cheatbook.github.io/builtins.html#bundles

[2022-09-29]
ã‚„ã£ã±ã‚Šã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã£ã¦ã„ã†ã®ã¯ã€ä½œã‚‹åŠªåŠ›ã‚ˆã‚Šã‚‚ä½¿ã†åŠªåŠ›ã®æ–¹ãŒåœ§å€’çš„ã«å¤§ãã„ã¨ã„ã†ã‹ã€å…¥åŠ›ã—ãŸæƒ…å ±ã«ã‚ˆã£ã¦ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ç„¡é™ã«ã•ã¾ã–ã¾ãªä½¿ã‚ã‚Œæ–¹ãŒã•ã‚Œã†ã‚‹ã®ãŒã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ã€Œæƒ³å®šã•ã‚ŒãŸä½¿ã‚ã‚Œæ–¹ã€ã‚’æ‰“ç ´ã™ã‚‹ã“ã¨ã«ã‚‚ãªã‚‹ä¸€æ–¹ã§ã€å±é™ºæ€§ã§ã‚‚ã‚ã‚‹ã‚ˆã­...
ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’ä½œã‚‹æ™‚ã€ã©ã†ã„ã†ãµã†ã«ãã‚ŒãŒä½¿ã‚ã‚Œã‚‹ã‹ã¨ã„ã†ãƒªã‚¹ã‚¯ã‚’ãªã‹ãªã‹è€ƒãˆã¥ã‚‰ã„ã¨ã„ã†ã®ãŒã‚ã‚‹
(cif fileã«ã¤ã„ã¦èª¿ã¹ã¦ã„ã¦æ€ã£ãŸã“ã¨...çµæ™¶æ§‹é€ ä¸€ã¤ã¨ã£ã¦ã‚‚ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è‡ªä½“ã¯è‡ªå‹•çš„ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿å–ã£ã¦ç‚¹ã‚„ç·šã‚’è¨˜è¿°ã«ã—ãŸãŒã£ã¦æç”»ã™ã‚‹ã ã‘ã ãŒã€ãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæç”»ã—ã†ã‚‹æ§‹é€ ã«ã¯ç„¡æ•°ã«ã•ã¾ã–ã¾ãªã‚‚ã®ãŒã‚ã£ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã¯ãã®ã•ã¾ã–ã¾ãªæ§‹é€ ã‚’å…¨ã¦æŠŠæ¡ã™ã‚‹ã“ã¨ã¯ã§ããªã„...)

Why Rust is Rusty? â†’ 
    There are so many "sugar syntaxes" in Rust.
    Rust's language specificaitons aren't simple, rather, some of the specificaitons seem to exist for a specific purpose...
    For example, things like "MemoField {..default()}". Where default() comes from!? â†’ actually this is from Bevy, not Rust. Through importing Bevy, you can simplify Default:default to just default...
    And there are many different ways to do similar or same thing.
    For example, how to unpack Option? You can match, or use unpack function, or use ? notation. (probably there's other methods that I don't know...)
        If you use match, you can nest the whole block of code with match, or otherwise, you can write the match on the first line and use break, continue or return.
    Unlike other languages, becoming able to read and analyze Rust code is itself a hard problem, because there are many syntaxes you don't know!
    For Haskell, theoretically, it is enough to know several sugar syntaxes (like `div` and do) and how to define typeclass, to be able to read Haskell code, if you are keen to look the source code back and forth to analyze what it does.
    In Haskell, even symbols that look like language features (such as . $ <$> =<< << >>), are actually one of normal functions with "infix" parameters. (Though, there are many so-called "extensions" that extend syntax to do weird things...) 
    So, Rust is not a simple language. Rather, it's complex and rusty.
Difference between Cloud Service and Web Services before cloud...
    Perhaps, difference between cloud service and web services before the era of cloud is that cloud service is autonomous and running various micro-programs behind the user interface, making the platform more opaque than web services.
    Contrary, web services are running according to user's command. In most cases, user is the originator of the program, like clicking a button and send some request through HTTP(S).
    In other words, cloud service is like a simulation game. In a simulation game, numerous micro-programs are running behind the user interface and the player can only see what's happening on the surface. Also, the ways the player can interact with the game are limited.
    In many cases, the player isn't the originator of these micro-programs. Instead, they are invoked by other programs, or periodic events, or happening randomly.
    Working with bevy, I feel like writing bevy code is like making a Mod program for space-simulation games such as Stellaris (by Paradox Interactive, Sweden) or X series (by Egosoft, Germany).
    Bevy's "data-driven" mechanism is 

[2022-10-04]
Working with fragment, entry, history hierarchy, and tags.
    list of fragments makes an entry.
    the graph structure of fragments makes fragment history.
    the graph structure of entries makes entry history.
â†’ look for graph structure: discussion here https://github.com/bevyengine/bevy/issues/5430

[2022-10-11]

Tutorial Reading: issues with language used in programming (executed, captured, etc.)
https://www.reuters.com/article/us-amazon-com-jobs-automation-insight-idUSKCN1MK08G

[2022-10-18]
difficult thing is... Closure/function is difficult to use in Rust... because of BORROWING!!! It is easier to avoid repetition by for-each loop than using closure, and using clousure than using functions.
Difficulty: function > closure > loops

Rust mut borrowing: you have to separate code into small components, because you can't borrow mut variable twice. if you write `let mut x = abc.def(1)`, then you have to focus on programming about x. You cannot do like `let mut y = abc.def(2)`.
