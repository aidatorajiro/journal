# Conclusion

As a coding experience, this project greatly helped me to understand the philosophy of Rust and Bevy. Both is similar because they encourages "modular" way of programming. For example in Rust, there's a feature called "moving". If a resource is "moved" from a variable to another variable, you can no longer use the original variable to access that resource. This prevent us from writing different types of information processing simultaneously. Instead, we are encouraged (or maybe forced) to focus on one thing at a time, splitting the code into small modules.  Bevy's ECS mechanism encourages splitting a program into a number of small `System`, and use `Entity`, `Resource`, or `Event`, which are open and can be accessed by any `System`, to communicate between them. This will give the program transparency and flexibility, making it easier to changing the behavior by directory manipulating them. However, the pitfall is the problem arising from running orders (i.e. race condition). The difference between Rust's moving/borrowing and Bevy's ECS is, while the former is for safely processing data sequentially, the latter is for efficiently processing data simultaneously and increasing flexibility of code.

The initial aim of this project is to create an alternative of cloud services like iCloud. Perhaps, difference between cloud service and web services before the era of cloud is that cloud service is autonomous and running various micro-programs behind the user interface, making the platform more opaque than traditional web services. Contrary, traditional web services mostly run according to user's command. User is the originator of the program, like clicking a button and send some request through HTTP(S). Cloud service is like a simulation game. In a simulation game, numerous micro-programs are running behind the user interface and the player can only see what's happening on the surface. Also, the ways the player can interact with the game are limited. The player isn't the originator of these micro-programs, they are invoked by other programs, or periodic events, or happening randomly. In that sense, I argue Bevy is the application framework in the era of cloud. Working with Bevy, I feel like writing Bevy code is like making a Mod program for space-simulation games such as Stellaris (by Paradox Interactive, Sweden) or X series (by Egosoft, Germany).